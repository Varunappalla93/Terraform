Terraform is Infrastructure as a code (IaaC) tool.
Can connect to any platform, multicloud, has version control,  we can have history of our infra, easy to restore.
can track changes and review, consistent infra acroess all envs.

CRUD - can check AWS services, inventory management

Cost optimization
Dependency management - automatic in terraform

Reusable infra using terraform modules

Install terraform on mac -> 
brew tap hashicorp/tap 
brew install hashicorp/tap/terraform

terraform --version ->
Terraform v1.14.5
on darwin_arm64

Now install aws cli v2 to connect to aws account and services and run aws configure

Providers - AWS is our provider in our case.

count based loops are for list -> count.index
for based loop for set -> set or map -> each.key and each.value
dynamic block - we get special variable with block name, eg: ingress
data source - query the provider for existing information

state - terraform tracks what it had created in state file, it is like memory to terraform.

.tf files  - declarative based infra

actual infra - what is actually created inside provider

desired infra - what terraform created

actual infra = desired infra

terraform creates resources in provider and stores in terraform.tfstate file

if terraform apply -auto-approve is given again and if its state file is matching with actual infra, no changes are applied

one previous state backup file will be available, i.e. .terraform.tfstate.backup file

state file is locked by terraform when we perform terraform actions

terraform.tf files is for us
state file is for terraform

In Collaboration env, state should be stored in remote like s3 bucket, so we can prevent errors and duplicated,
it should be locked and parallel modifications should not be allowed.

No one should not have access to delete terraform remote state file except terraform

versions should ne enabled and data replication should be done another bucket

locals are like variables with extra capabilities

Provisioners - to take actions or run scripts before or after the task, they only execute while creation or destroy, but not
at updating of resources , used to call ansible playbooks


To create multiple envs - we can use terraform workspaces, terraform wil give us a special variable called terraform.workspace
or using .tfvars or using separate repos.

using terraform workspaces:
give "terraform workspace" to see its options:
  new, list, show, select and delete Terraform workspaces.

Subcommands:
    delete    Delete a workspace
    list      List Workspaces
    new       Create a new workspace
    select    Select a workspace
    show      Show the name of the current workspace


we must do terraform init before giving workspace commands.

terraform workspace list -> has only default workspace for now

terraform workspace new dev -> to create new workspace dev

terraform workspace new prod -> to create new workspace prod

terraform workspace list -> now its switched to prod

Advantages -> same code, consistent envs.
Disadvantage -> Since code is same, changes will be applied to prod env also.


using tf vars:
terraform init -backend-config=dev/backend.tf -> to configure dev env instance using tf vars

terraform init -reconfigure -backend-config=prod/backend.tf  -> to reconfigure prod env instance using tf vars

terraform plan -var-file=dev/terraform.tfvars -> to plan dev env instance using tf vars

terraform apply -auto-approve -var-file=dev/terraform.tfvars  -> to apply dev env instance using tf vars

terraform destroy -var-file=dev/terraform.tfvars -auto-approve  -> to destroy dev env instance using tf vars

Advantages -> same code, consistent envs.
Disadvantage -> Since code is same, changes will be applied to prod env also.


using separate repos: eg: terrafofm-ec2-dev, terraform-ec2-prod

Advantages -> clear isolation between envs, blast isolation is zero, separate state
Disadvantage -> code repetition

Terraform Modules -> Earlier we used terraform workspace or tfvars , but it was difficult to manage, hence we moved to 
terraform modules (Similar to functions), so that we can use same code , and it is easy to maintain.


VPC - it is like a data center where we can create resources to our project in isolated space.

Subnets:
A subnet (subnetwork) is a logical subdivision of an IP network, used to improve performance, security, 
and manageability by dividing large networks into smaller, more efficient, and organized segments. It enables 
faster data routing by reducing unnecessary traffic, often using a subnet mask to split IP addresses into network and host components.

Public subnets have direct, two-way routing to the internet via an Internet Gateway (IGW), making them ideal for web servers and
public-facing resources. Private subnets lack a direct internet route, shielding internal resources like databases from the internet, 
and usually require a NAT Gateway for outbound internet access.

Public: Web servers, Load Balancers, Bastion hosts.
Private: Databases, application servers, backend services, internal data.

An Internet Gateway is a bidirectional, free component allowing public, direct internet access (inbound and outbound) 
to resources with public IPs. 

A NAT Gateway is a chargeable service allowing only outbound internet access for private instances, 
securing them from unsolicited inbound connections.

IGW is attached to a VPC for public subnets; NGW is placed in a public subnet to serve instances in a private subnet.

Internet Gateway: Use for web servers, public-facing applications, or services requiring incoming traffic from the internet.
NAT Gateway: Use when you have private instances (like application servers or databases) 
that need to download patches or connect to third-party APIs without being exposed to the public.

Private instances often use a NAT Gateway to send traffic, which then passes through the Internet Gateway to reach the internet.

IP address - IPv4 - 32 bits.

varies from 0.0.0.0 to 255.255.255.255

IP address : network + host 
eg: 10.0.0.0/16 -> 16 bits are reserved for network, 16 for host/server.
2^16 -> 65,536 IP address are possible.


Classless Inter-Domain Routing (CIDR) is a method for allocating IP addresses and routing packets efficiently,
replacing the older, rigid system of Class A, B, and C networks. It uses a slash notation to define a network prefix, 
allowing for flexible, custom-sized subnets and reducing IPv4 address waste.

AWS range - 16 to 28 CIDR.

10.0.0.0/16 -> VPC CIDR 
10.0.0.0/24 -> subnets , 8 bits-> 256 subnets, each subnet can have 2^8 IP addressess.


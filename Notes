Terraform is Infrastructure as a code (IaaC) tool.
Can connect to any platform, multicloud, has version control,  we can have history of our infra, easy to restore.
can track changes and review, consistent infra acroess all envs.

CRUD - can check AWS services, inventory management

Cost optimization
Dependency management - automatic in terraform

Reusable infra using terraform modules

Install terraform on mac -> 
brew tap hashicorp/tap 
brew install hashicorp/tap/terraform

terraform --version ->
Terraform v1.14.5
on darwin_arm64

Now install aws cli v2 to connect to aws account and services and run aws configure

Providers - AWS is our provider in our case.

count based loops are for list -> count.index
for based loop for set -> set or map -> each.key and each.value
dynamic block - we get special variable with block name, eg: ingress
data source - query the provider for existing information

state - terraform tracks what it had created in state file, it is like memory to terraform.

.tf files  - declarative based infra

actual infra - what is actually created inside provider

desired infra - what terraform created

actual infra = desired infra

terraform creates resources in provider and stores in terraform.tfstate file

if terraform apply -auto-approve is given again and if its state file is matching with actual infra, no changes are applied

one previous state backup file will be available, i.e. .terraform.tfstate.backup file

state file is locked by terraform when we perform terraform actions

terraform.tf files is for us
state file is for terraform

In Collaboration env, state should be stored in remote like s3 bucket, so we can prevent errors and duplicated,
it should be locked and parallel modifications should not be allowed.

No one should not have access to delete terraform remote state file except terraform

versions should ne enabled and data replication should be done another bucket

locals are like variables with extra capabilities

Provisioners - to take actions or run scripts before or after the task, they only execute while creation or destroy, but not
at updating of resources , used to call ansible playbooks


To create multiple envs - we can use terraform workspaces, terraform wil give us a special variable called terraform.workspace
or using .tfvars or using separate repos.

using terraform workspaces:
give "terraform workspace" to see its options:
  new, list, show, select and delete Terraform workspaces.

Subcommands:
    delete    Delete a workspace
    list      List Workspaces
    new       Create a new workspace
    select    Select a workspace
    show      Show the name of the current workspace


we must do terraform init before giving workspace commands.

terraform workspace list -> has only default workspace for now

terraform workspace new dev -> to create new workspace dev

terraform workspace new prod -> to create new workspace prod

terraform workspace list -> now its switched to prod

Advantages -> same code, consistent envs.
Disadvantage -> Since code is same, changes will be applied to prod env also.


using tf vars:
terraform init -backend-config=dev/backend.tf -> to configure dev env instance using tf vars

terraform init -reconfigure -backend-config=prod/backend.tf  -> to reconfigure prod env instance using tf vars

terraform plan -var-file=dev/terraform.tfvars -> to plan dev env instance using tf vars

terraform apply -auto-approve -var-file=dev/terraform.tfvars  -> to apply dev env instance using tf vars

terraform destroy -var-file=dev/terraform.tfvars -auto-approve  -> to destroy dev env instance using tf vars

Advantages -> same code, consistent envs.
Disadvantage -> Since code is same, changes will be applied to prod env also.


using separate repos: eg: terrafofm-ec2-dev, terraform-ec2-prod

Advantages -> clear isolation between envs, blast isolation is zero, separate state
Disadvantage -> code repetition

Terraform Modules -> Earlier we used terraform workspace or tfvars , but it was difficult to manage, hence we moved to 
terraform modules (Similar to functions), so that we can use same code , and it is easy to maintain.


VPC - it is like a data center where we can create resources to our project in isolated space.

Subnets:
A subnet (subnetwork) is a logical subdivision of an IP network, used to improve performance, security, 
and manageability by dividing large networks into smaller, more efficient, and organized segments. It enables 
faster data routing by reducing unnecessary traffic, often using a subnet mask to split IP addresses into network and host components.

Public subnets have direct, two-way routing to the internet via an Internet Gateway (IGW), making them ideal for web servers and
public-facing resources. Private subnets lack a direct internet route, shielding internal resources like databases from the internet, 
and usually require a NAT Gateway for outbound internet access.

Public: Web servers, Load Balancers, Bastion hosts.
Private: Databases, application servers, backend services, internal data.

An Internet Gateway is a bidirectional, free component allowing public, direct internet access (inbound and outbound) 
to resources with public IPs. 

A NAT Gateway is a chargeable service allowing only outbound internet access for private instances, 
securing them from unsolicited inbound connections.

IGW is attached to a VPC for public subnets; NGW is placed in a public subnet to serve instances in a private subnet.

Internet Gateway: Use for web servers, public-facing applications, or services requiring incoming traffic from the internet.
NAT Gateway: Use when you have private instances (like application servers or databases) 
that need to download patches or connect to third-party APIs without being exposed to the public.

Private instances often use a NAT Gateway to send traffic, which then passes through the Internet Gateway to reach the internet.

IP address - IPv4 - 32 bits.

varies from 0.0.0.0 to 255.255.255.255

IP address : network + host 
eg: 10.0.0.0/16 -> 16 bits are reserved for network, 16 for host/server.
2^16 -> 65,536 IP address are possible.


Classless Inter-Domain Routing (CIDR) is a method for allocating IP addresses and routing packets efficiently,
replacing the older, rigid system of Class A, B, and C networks. It uses a slash notation to define a network prefix, 
allowing for flexible, custom-sized subnets and reducing IPv4 address waste.

AWS range - 16 to 28 CIDR.

10.0.0.0/16 -> VPC CIDR 
10.0.0.0/24 -> subnets , 8 bits-> 256 subnets, each subnet can have 2^8 IP addressess.

Create VPC and create internet gateway and attach internet gateway to create VPC eg: roboshop.

Now under our created VPC, we need to create subnets:
Now create 1 public subnet for 1 Availablity Zone, eg: us-east-1a
eg: 10.0.1.0/24 subnet for 10.0.0.0/16 CIDR, i.e. VPC

we can create another public subnet for another availablity zone,  eg: us-east-1b
eg: 10.0.2.0/24 subnet for 10.0.0.0/16 CIDR, i.e. VPC


we can create another private subnet for another availablity zone, and for another AZ as well
eg: 10.0.11.0/24 subnet for 10.0.0.0/16 CIDR, i.e. VPC


we can create another DB subnet for another availablity zone and for another AZ as well
eg: 10.0.21.0/24 subnet for 10.0.0.0/16 CIDR, i.e. VPC

Now under our created VPC, we need to create route table.
Now we need to attach respective subnets to route tables via Edit subnet associations
eg: roboshop-public-us-east-1a and roboshop-public-us-east-1b to created route table, ie. roboshop-public-routetable

now for created public route table, eg:roboshop-public-routetable, under routes - we need to attach our created internet gateway and give destination as 0.0.0.0 for access to internet through internet gateway, i.e. now both created public subnets have internet access through internet gateway.

Same for private route table:
create one private route table and attach respective subnets but we should not give internet access to private route table.

Same for DB route table:
create one DB route table and attach respective subnets but we should not give internet access to DB route table.

Overview:
AWS Account - VPC(AZ1, AZ2) - Subnets 

ingress - Incoming traffic comes to servers
egress - outgoing traffic/data going out from servers/VPC

eg: dnf install mysql -y -> outgoing/egress traffic

NAT gateway - if the nstances in private subnet /DB subnet wants to connect to internet to dowload or upload packages, they should go via NAT gateway,
NAT gateway allows only outbound traffic.

Elastic IP/Static IP is mandatory to create NAT gateway.

Create/Allocate one Elastic IP address to any AZ, eg: us-east-1a 

Now create one NAT gateway -> select AZ as zonal and select respective created subnet
eg: roboshop-public-us-east-1a for NAT gateway to be created only in that public subnet, but in real projects, select regional and select created VPC, and then NAT getway will be created in all public subnets.

Also select public as connectivity type and select Manual method as Elastic IP and select created elastic ip address.


Now for private route table , under routes edit and add route and give destination as 0.0.0.0 and target as NAT gateway and select our
respective NAT gateway.

Now for DB route table , under routes edit and add route and give destination as 0.0.0.0 and target as NAT gateway and select our
respective NAT gateway.

